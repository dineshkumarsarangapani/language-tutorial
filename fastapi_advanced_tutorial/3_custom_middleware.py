# 3. Custom Middleware

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import time

app = FastAPI()

# --- What is Middleware? ---
# Middleware is a function that works with every request before it is processed
# by a specific path operation, and with every response before it is returned.
# It can perform actions like:
# - Adding custom headers (e.g., X-Process-Time).
# - Logging requests and responses.
# - Handling authentication or authorization.
# - Modifying the request or response object.
# - Catching exceptions globally and formatting error responses.

# --- Creating Custom Middleware ---
# Middleware can be added using the `@app.middleware("http")` decorator on an
# async function that takes `request: Request` and `call_next` as arguments.
# - `request`: The Request object.
# - `call_next`: A function that receives the `request` as a parameter. This
#   function will pass the request to the corresponding path operation.
#   It returns the `Response` generated by the path operation.
# You *must* call `await call_next(request)` to execute the path operation and get the response.

# --- Example 1: Adding a Process Time Header ---
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    print(f"Middleware: Request received for {request.url.path}")
    start_time = time.time()
    
    # Process the request and get the response
    response = await call_next(request)
    
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    print(f"Middleware: Response for {request.url.path} processed in {process_time:.4f} secs")
    return response

# --- Example 2: Custom Error Handling Middleware ---
# This middleware catches a specific custom exception and returns a formatted JSON response.
class MyCustomException(Exception):
    def __init__(self, name: str, detail: str):
        self.name = name
        self.detail = detail

@app.middleware("http")
async def custom_exception_handler_middleware(request: Request, call_next):
    print(f"Middleware (Exception Handler): Checking request to {request.url.path}")
    try:
        response = await call_next(request)
        return response
    except MyCustomException as exc:
        print(f"Middleware: MyCustomException caught: {exc.name} - {exc.detail}")
        return JSONResponse(
            status_code=418, # I'm a teapot (or any appropriate error code)
            content={"error_type": "MyCustomError", "name": exc.name, "message": exc.detail}
        )
    except Exception as exc: # Catching other unexpected errors
        print(f"Middleware: An unexpected error occurred: {exc}")
        # In a real app, you might want to log this traceback and return a generic 500
        return JSONResponse(
            status_code=500,
            content={"error_type": "InternalServerError", "message": "An unexpected error occurred."}
        )

# Note: Order of middleware matters.
# They are processed in the order they are added for requests (top to bottom).
# For responses, they are processed in reverse order (bottom to top).
# So, `add_process_time_header` will wrap `custom_exception_handler_middleware`.
# This means `add_process_time_header` will also measure the time taken by the exception handler if an exception occurs.

# --- Example Path Operations ---
@app.get("/")
async def root():
    time.sleep(0.1) # Simulate some work
    return {"message": "Hello World"}

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id == "error":
        raise MyCustomException(name="ItemProcessingError", detail=f"Failed to process item '{item_id}'")
    if item_id == "unexpected":
        result = 10 / 0 # This will raise a ZeroDivisionError
        return {"item_id": item_id, "result": result} # Unreachable
    time.sleep(0.05)
    return {"item_id": item_id}

@app.post("/data")
async def create_data(payload: dict):
    time.sleep(0.15)
    return {"status": "data received", "payload": payload}

# To run this example:
# 1. Save as a Python file (e.g., main_mw.py)
# 2. Run with Uvicorn: `uvicorn main_mw:app --reload`
# 3. Open your browser to http://127.0.0.1:8000/docs
#    - Call `/` and `/items/some_item`. Check response headers for `X-Process-Time`.
#    - Call `/items/error` to see the custom exception handling.
#    - Call `/items/unexpected` to see the generic exception handling by the middleware.
#    - Observe the console logs to see middleware execution order.

print("--- Custom Middleware ---")
print("FastAPI application demonstrating custom middleware.")
print("Middleware can process requests before they hit the path operation and responses before they are sent.")
print("Run with: uvicorn filename:app --reload (e.g., uvicorn 3_custom_middleware:app --reload)") 